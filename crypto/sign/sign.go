package sign

import (
	"errors"
	"io"

	"github.com/karalef/quark/crypto"
	"github.com/karalef/quark/internal"
)

// Generate derives a key-pair from a seed generated by provided rand.
//
// If rand is nil, crypto/rand is used.
func Generate(s Scheme, rand io.Reader) (PrivateKey, PublicKey, error) {
	seed, err := crypto.RandRead(rand, s.SeedSize())
	if err != nil {
		return nil, nil, err
	}
	return s.DeriveKey(seed)
}

// Scheme represents signature scheme.
type Scheme interface {
	Name() string

	// DeriveKey derives a key-pair from a seed.
	DeriveKey(seed []byte) (PrivateKey, PublicKey, error)

	// Unpacks a PublicKey from the provided bytes.
	UnpackPublic(key []byte) (PublicKey, error)

	// Unpacks a PrivateKey from the provided bytes.
	UnpackPrivate(key []byte) (PrivateKey, error)

	// Size of packed public keys.
	PublicKeySize() int

	// Size of packed private keys.
	PrivateKeySize() int

	// Size of signatures.
	SignatureSize() int

	// Size of seed.
	SeedSize() int
}

// Signer represents a signature state.
type Signer interface {
	io.Writer

	// Reset resets the Signer.
	Reset()

	// Sign signs the written message and returns the signature.
	Sign() []byte
}

// Verifier represents a signature verification state.
type Verifier interface {
	io.Writer

	// Reset resets the Verifier.
	Reset()

	// Verify checks whether the given signature is a valid signature set by
	// the private key corresponding to the specified public key on the
	// written message.
	// Returns an error if the signature does not match the scheme.
	Verify(signature []byte) (bool, error)
}

// PrivateKey represents a signing private key.
type PrivateKey interface {
	Scheme() Scheme
	Public() PublicKey
	Equal(PrivateKey) bool

	// Pack allocates a new slice of bytes with Scheme().PrivateKeySize() length
	// and writes the private key to it.
	Pack() []byte

	Sign([]byte) []byte
}

// PublicKey represents a signing public key.
type PublicKey interface {
	Scheme() Scheme
	Equal(PublicKey) bool

	// Pack allocates a new slice of bytes with Scheme().PublicKeySize() length
	// and writes the public key to it.
	Pack() []byte

	Verify(message, signature []byte) (bool, error)
}

// StreamPrivateKey represents a private key supporting streaming signatures.
type StreamPrivateKey interface {
	PrivateKey
	Signer() Signer
}

// StreamPublicKey represents a public key supporting streaming signatures.
type StreamPublicKey interface {
	PublicKey
	Verifier() Verifier
}

// errors.
var (
	ErrSignature = errors.New("invalid signature")
	ErrSeedSize  = errors.New("invalid seed size")
	ErrKeySize   = errors.New("invalid key size")
)

var schemes = make(internal.Schemes[Scheme])

// Register registers a signature scheme.
func Register(scheme Scheme) { schemes.Register(scheme) }

// ByName returns the signature scheme by the provided name.
// Returns nil if the name is not registered.
func ByName(name string) Scheme { return schemes.ByName(name) }

// ListAll returns all registered signature algorithms.
func ListAll() []string { return schemes.ListAll() }

// ListSchemes returns all registered signature schemes.
func ListSchemes() []Scheme { return schemes.ListSchemes() }
