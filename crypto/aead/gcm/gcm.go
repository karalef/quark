// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// package gcm implements Galois Counter Mode with stream api.
// Almost all the code is copied from crypto/cipher/gcm.go (stdlib) and modified
// to work with data streams, but at the cost of performance (there is no
// arch-specific implementation).
//
// WARNING: The author of this package is not a cryptographer, so the
// implementation may have vulnerabilities.
package gcm

import (
	"crypto/cipher"
	"crypto/subtle"
	"encoding/binary"
	"errors"

	"github.com/karalef/quark/crypto"
	"github.com/karalef/quark/crypto/aead/internal"
	"github.com/karalef/quark/crypto/aead/internal/alias"
)

// consts.
const (
	// GCM and cipher block size.
	BlockSize = 16

	// Standard nonce size.
	NonceSize = 12

	// Standard tag size.
	TagSize = 16

	minimumTagSize = 12 // NIST SP 800-38D recommends tags with 12 or more bytes.

	ciphertextMax = ((1 << 32) - 2) * uint64(BlockSize)
)

var (
	errNonceSize = errors.New("gcm: the nonce can't have zero length, or the security of the key will be immediately compromised")
	errTagSize   = errors.New("gcm: incorrect tag size")
	errBlockSize = errors.New("gcm: GCM requires 128-bit block cipher")
)

var _ internal.Cipher = (*gcm)(nil)

// NewCipher returns a new GCM from block cipher.
func NewCipher(block cipher.Block, nonce, ad []byte, tagSize int) *gcm {
	if block.BlockSize() != BlockSize {
		panic(errBlockSize)
	}
	if tagSize < minimumTagSize || tagSize > BlockSize {
		panic(errTagSize)
	}
	if len(nonce) == 0 {
		panic(errNonceSize)
	}

	g := &gcm{
		block:   block,
		tagSize: tagSize,
	}

	var key [BlockSize]byte
	block.Encrypt(key[:], key[:])

	// We precompute 16 multiples of |key|. However, when we do lookups
	// into this table we'll be using bits from a field element and
	// therefore the bits will be in the reverse order. So normally one
	// would expect, say, 4*key to be in index 4 of the table but due to
	// this bit ordering it will actually be in index 0010 (base 2) = 2.
	x := fieldElement{
		binary.BigEndian.Uint64(key[:8]),
		binary.BigEndian.Uint64(key[8:]),
	}
	g.table[reverseBits(1)] = x

	for i := 2; i < 16; i += 2 {
		g.table[reverseBits(i)] = g.table[reverseBits(i/2)].double()
		g.table[reverseBits(i+1)] = g.table[reverseBits(i)].add(&x)
	}

	g.reset(nonce, ad)

	return g
}

// reverseBits reverses the order of the bits of 4-bit number in i.
func reverseBits(i int) int {
	i = ((i << 2) & 0xc) | ((i >> 2) & 0x3)
	i = ((i << 1) & 0xa) | ((i >> 1) & 0x5)
	return i
}

type gcm struct {
	block   cipher.Block
	counter [BlockSize]byte

	// used only if delim > 0.
	// keyStream[:delim] contains ciphertext that not yet been used to update the
	// gcm state.
	// keyStream[delim:] contains the key stream that has not been used.
	keyStream [BlockSize]byte
	delim     int

	adLen, ctLen uint64

	y       fieldElement
	table   [16]fieldElement
	tagMask [BlockSize]byte
	tagSize int
}

func (g *gcm) TagSize() int { return g.tagSize }

func (g *gcm) reset(nonce, ad []byte) {
	g.delim = 0
	g.ctLen = 0
	g.adLen = uint64(len(ad))
	g.y = fieldElement{}

	g.update(&g.y, ad)

	// GCM has two modes of operation with respect to the initial counter
	// state: a "fast path" for 96-bit (12-byte) nonces, and a "slow path"
	// for nonces of other lengths. For a 96-bit nonce, the nonce, along
	// with a four-byte big-endian counter starting at one, is used
	// directly as the starting counter. For other nonce sizes, the counter
	// is computed by passing it through the GHASH function.
	if len(nonce) == NonceSize {
		copy(g.counter[:], nonce)
		g.counter[BlockSize-1] = 1
	} else {
		var y fieldElement
		g.update(&y, nonce)
		y.high ^= uint64(len(nonce)) * 8
		y.mul(&g.table)
		binary.BigEndian.PutUint64(g.counter[:8], y.low)
		binary.BigEndian.PutUint64(g.counter[8:], y.high)
	}

	g.encryptCounter(g.tagMask[:])
}

// encryptCounter writes the key stream generated by the block cipher into dst
// and increments the counter.
func (g *gcm) encryptCounter(dst []byte) {
	g.block.Encrypt(dst, g.counter[:])
	ctr := g.counter[len(g.counter)-4:]
	binary.BigEndian.PutUint32(ctr, binary.BigEndian.Uint32(ctr)+1)
}

// xorKeyStream encrypts a counter, increments it and XORs it with src. It
// returns the number of XORed bytes.
func (g *gcm) xorKeyStream(dst, src []byte) int {
	g.encryptCounter(g.keyStream[:])
	return subtle.XORBytes(dst, src, g.keyStream[:])
}

// updateBlock extends y with more polynomial terms from block, based on
// Horner's rule.
func (g *gcm) updateBlock(y *fieldElement, block []byte) {
	y.low ^= binary.BigEndian.Uint64(block)
	y.high ^= binary.BigEndian.Uint64(block[8:])
	y.mul(&g.table)
}

// update extends y with more polynomial terms from data. If data is not a
// multiple of gcmBlockSize bytes long then the remainder is zero padded.
func (g *gcm) update(y *fieldElement, data []byte) {
	for len(data) >= BlockSize {
		g.updateBlock(y, data)
		data = data[BlockSize:]
	}

	if len(data) > 0 {
		var padded [BlockSize]byte
		copy(padded[:], data)
		g.updateBlock(y, padded[:])
	}
}

func (g *gcm) tag(out []byte) {
	if g.delim > 0 { // drain buffered ciphertext
		clear(g.keyStream[g.delim:])
		g.updateBlock(&g.y, g.keyStream[:])
		g.delim = 0
	}

	g.y.low ^= g.adLen * 8
	g.y.high ^= g.ctLen * 8

	g.y.mul(&g.table)

	binary.BigEndian.PutUint64(out, g.y.low)
	binary.BigEndian.PutUint64(out[8:], g.y.high)

	subtle.XORBytes(out, out, g.tagMask[:])
}

func (g *gcm) crypt(dst, src, ct []byte) {
	if len(src) == 0 {
		return
	}
	if len(dst) < len(src) {
		panic("gcm: output smaller than input")
	}
	dst = dst[:len(src)]
	if alias.InexactOverlap(dst, src) {
		panic("gcm: invalid buffer overlap")
	}
	g.ctLen += uint64(len(src))
	if g.ctLen > ciphertextMax {
		panic("gcm: message too large")
	}

	// drain key stream and buffered ciphertext
	if g.delim > 0 {
		n := subtle.XORBytes(dst, src, g.keyStream[g.delim:])
		copy(g.keyStream[g.delim:], ct[:n])
		g.delim += n
		if g.delim < BlockSize {
			return
		}
		g.updateBlock(&g.y, g.keyStream[:])
		g.delim = 0
		dst, src, ct = dst[n:], src[n:], ct[n:]
	}

	// process full blocks
	for len(src) >= BlockSize {
		g.xorKeyStream(dst, src)
		g.updateBlock(&g.y, ct)
		dst, src, ct = dst[BlockSize:], src[BlockSize:], ct[BlockSize:]
	}

	// crypt the rest and buffer the ciphertext
	if len(src) > 0 {
		g.delim = g.xorKeyStream(dst, src)
		copy(g.keyStream[:g.delim], ct)
	}
}

// Encrypt encrypts src and updates the GCM state.
func (g *gcm) Encrypt(dst, src []byte) { g.crypt(dst, src, dst) }

// Decrypt decrypts src and updates the GCM state.
func (g *gcm) Decrypt(dst, src []byte) { g.crypt(dst, src, src) }

// Tag calculates GHASH of the data and appends the result to dst.
func (g *gcm) Tag(dst []byte) []byte {
	dst, tail := crypto.ExtendSlice(dst, g.tagSize)
	g.tag(tail)
	return dst
}

// Reset resets the counter and state.
func (g *gcm) Reset(nonce, ad []byte) {
	if len(nonce) == 0 {
		panic(errNonceSize)
	}
	g.reset(nonce, ad)
}

// fieldElement represents a value in GF(2¹²⁸). The bits are stored in big
// endian order.
//
//	the coefficient of x⁰ can be obtained by v.low >> 63.
//	the coefficient of x⁶³ can be obtained by v.low & 1.
//	the coefficient of x⁶⁴ can be obtained by v.high >> 63.
//	the coefficient of x¹²⁷ can be obtained by v.high & 1.
type fieldElement struct {
	low, high uint64
}

func (x *fieldElement) add(y *fieldElement) fieldElement {
	return fieldElement{x.low ^ y.low, x.high ^ y.high}
}

// double returns the result of doubling an element of GF(2¹²⁸).
func (x *fieldElement) double() (double fieldElement) {
	// Because of the bit-ordering, doubling is actually a right shift.
	double.high = x.high >> 1
	double.high |= x.low << 63
	double.low = x.low >> 1

	// If the most-significant bit was set before shifting then it,
	// conceptually, becomes a term of x^128. This is greater than the
	// irreducible polynomial so the result has to be reduced. The
	// irreducible polynomial is 1+x+x^2+x^7+x^128. We can subtract that to
	// eliminate the term at x^128 which also means subtracting the other
	// four terms. In characteristic 2 fields, subtraction == addition ==
	// XOR.
	if x.high&1 == 1 {
		double.low ^= 0xe100000000000000
	}

	return
}

func (y *fieldElement) mul(H *[16]fieldElement) {
	var z fieldElement

	for i := 0; i < 2; i++ {
		word := y.high
		if i == 1 {
			word = y.low
		}

		// Multiplication works by multiplying z by 16 and adding in
		// one of the precomputed multiples of H.
		for j := 0; j < 64; j += 4 {
			msw := z.high & 0xf
			z.high >>= 4
			z.high |= z.low << 60
			z.low >>= 4
			z.low ^= uint64(reductionTable[msw]) << 48

			// the values in |table| are ordered for
			// little-endian bit positions.
			t := H[word&0xf]

			z.low ^= t.low
			z.high ^= t.high
			word >>= 4
		}
	}

	*y = z
}

var reductionTable = []uint16{
	0x0000, 0x1c20, 0x3840, 0x2460, 0x7080, 0x6ca0, 0x48c0, 0x54e0,
	0xe100, 0xfd20, 0xd940, 0xc560, 0x9180, 0x8da0, 0xa9c0, 0xb5e0,
}
